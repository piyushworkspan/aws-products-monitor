# .github/workflows/aws-products-monitor.yml
name: AWS Products Monitor

on:
  schedule:
    - cron: ${{ vars.MONITOR_SCHEDULE || '0 */6 * * *' }}  # Configurable schedule, default every 6 hours
  workflow_dispatch:  # Allow manual trigger
  
env:
  MONITORED_FILE_URL: ${{ vars.MONITORED_FILE_URL || 'https://raw.githubusercontent.com/aws-samples/partner-crm-integration-samples/main/resources/aws_products.json' }}
  JIRA_PROJECT_KEY: ${{ vars.JIRA_PROJECT_KEY || 'PMT' }}
  MONITOR_NAME: ${{ vars.MONITOR_NAME || 'AWS Products' }}

jobs:
  monitor-file-changes:
    runs-on: ubuntu-latest
    
    steps:
    - name: Display Configuration
      run: |
        echo "üîß Monitor Configuration:"
        echo "=============================="
        echo "üìÅ File URL: ${{ env.MONITORED_FILE_URL }}"
        echo "üé´ JIRA Project: ${{ env.JIRA_PROJECT_KEY }}"
        echo "üìù Monitor Name: ${{ env.MONITOR_NAME }}"
        echo "‚è∞ Schedule: ${{ vars.MONITOR_SCHEDULE || '0 */6 * * *' }}"
        echo "üè¢ Repository: ${{ github.repository }}"
        echo ""
    
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        pip install requests openai jira python-dotenv
        
    - name: Download current monitored file
      run: |
        echo "üì• Downloading file from: ${{ env.MONITORED_FILE_URL }}"
        curl -s "${{ env.MONITORED_FILE_URL }}" > current_file.json
        
        if [ $? -eq 0 ] && [ -s current_file.json ]; then
          echo "‚úÖ Successfully downloaded file"
          FILE_SIZE=$(wc -c < current_file.json)
          echo "üìä File size: $FILE_SIZE bytes"
        else
          echo "‚ùå Failed to download file or file is empty"
          exit 1
        fi
        
    - name: Get previous version from artifacts
      uses: actions/download-artifact@v4
      with:
        name: ${{ env.MONITOR_NAME }}-baseline
        path: ./
      continue-on-error: true
      
    - name: Detect changes in monitored file
      id: detect_changes
      run: |
        if [ -f "previous_file.json" ]; then
          echo "üìÅ Found previous baseline file"
          
          if ! cmp -s "previous_file.json" "current_file.json"; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "üö® Changes detected in monitored file!"
            
            # File size comparison
            PREV_SIZE=$(wc -c < previous_file.json)
            CURR_SIZE=$(wc -c < current_file.json)
            SIZE_DIFF=$((CURR_SIZE - PREV_SIZE))
            
            echo "üìä Previous size: $PREV_SIZE bytes"
            echo "üìä Current size: $CURR_SIZE bytes"
            echo "üìä Size change: $SIZE_DIFF bytes"
            
            echo "prev_size=$PREV_SIZE" >> $GITHUB_OUTPUT
            echo "curr_size=$CURR_SIZE" >> $GITHUB_OUTPUT
            echo "size_diff=$SIZE_DIFF" >> $GITHUB_OUTPUT
            
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No changes detected in monitored file"
          fi
        else
          echo "üìÅ No previous baseline - first run or artifact expired"
          echo "changes_detected=false" >> $GITHUB_OUTPUT
          echo "first_run=true" >> $GITHUB_OUTPUT
        fi
        
    - name: Analyze changes and create JIRA ticket
      if: steps.detect_changes.outputs.changes_detected == 'true'
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        JIRA_URL: ${{ secrets.JIRA_URL }}
        ENGINEERING_MANAGER_EMAIL: ${{ secrets.ENGINEERING_MANAGER_EMAIL }}
        MONITOR_DESCRIPTION: ${{ vars.MONITOR_DESCRIPTION || 'Automated monitoring system detected changes in the tracked file' }}
      run: |
        python << 'EOF'
        import json
        import os
        import hashlib
        from datetime import datetime
        from openai import OpenAI
        from jira import JIRA
        
        # Configuration from environment
        MONITOR_NAME = os.getenv('MONITOR_NAME', 'File Monitor')
        JIRA_PROJECT_KEY = os.getenv('JIRA_PROJECT_KEY', 'PMT')
        MONITORED_URL = os.getenv('MONITORED_FILE_URL')
        MONITOR_DESC = os.getenv('MONITOR_DESCRIPTION', 'File monitoring system detected changes')
        
        print(f"ü§ñ Starting analysis for {MONITOR_NAME}")
        print(f"üé´ Target JIRA project: {JIRA_PROJECT_KEY}")
        
        # Load files
        try:
            with open('previous_file.json', 'r') as f:
                previous_data = json.load(f)
            with open('current_file.json', 'r') as f:
                current_data = json.load(f)
                
            print("‚úÖ Successfully loaded both files for comparison")
            
        except Exception as e:
            print(f"‚ùå Error loading files: {e}")
            exit(1)
        
        # Generate file hashes for tracking
        def get_hash(data):
            return hashlib.sha256(json.dumps(data, sort_keys=True).encode()).hexdigest()[:8]
        
        prev_hash = get_hash(previous_data)
        curr_hash = get_hash(current_data)
        
        print(f"üìä Previous hash: {prev_hash}")
        print(f"üìä Current hash: {curr_hash}")
        
        # AI Analysis
        try:
            openai_client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
            
            # Create analysis prompt
            prompt = f"""
            The monitored file "{MONITOR_NAME}" has been updated. 
            
            File URL: {MONITORED_URL}
            Previous hash: {prev_hash}
            Current hash: {curr_hash}
            
            This appears to be related to: {MONITOR_DESC}
            
            Based on the file change, provide analysis in this JSON format:
            
            {{
                "summary": "Brief description of what likely changed in this file",
                "total_changes": 1,
                "priority": "medium",
                "changes": [
                    {{
                        "change_type": "modified",
                        "item_name": "{MONITOR_NAME}",
                        "details": "File content updated - manual review recommended",
                        "impact_level": "medium"
                    }}
                ],
                "action_items": [
                    "Review the updated file for specific changes",
                    "Update related systems or processes as needed",
                    "Test any integrations that depend on this file",
                    "Notify relevant team members of the changes"
                ],
                "system_updates_needed": [
                    "Review file changes in relevant admin consoles",
                    "Update dependent configurations if needed",
                    "Test related functionality",
                    "Document changes for team reference"
                ]
            }}
            
            Tailor the response to be appropriate for the type of file being monitored.
            """
            
            print("üß† Analyzing changes with AI...")
            
            response = openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": f"You are analyzing changes to a monitored file ({MONITOR_NAME}) for a development/operations team. Provide actionable insights."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=800
            )
            
            analysis_text = response.choices[0].message.content
            
            # Parse AI response
            start = analysis_text.find('{')
            end = analysis_text.rfind('}') + 1
            
            if start >= 0 and end > start:
                analysis = json.loads(analysis_text[start:end])
                print("‚úÖ AI analysis completed successfully")
            else:
                raise ValueError("Could not parse AI response")
                
        except Exception as e:
            print(f"‚ö†Ô∏è AI analysis failed ({e}), using fallback analysis")
            
            analysis = {
                "summary": f"{MONITOR_NAME} file updated (hash: {prev_hash} ‚Üí {curr_hash})",
                "total_changes": 1,
                "priority": "medium",
                "changes": [
                    {
                        "change_type": "modified",
                        "item_name": MONITOR_NAME,
                        "details": "Monitored file changed - manual review required",
                        "impact_level": "medium"
                    }
                ],
                "action_items": [
                    f"Review changes in {MONITOR_NAME}",
                    "Identify specific modifications made",
                    "Update dependent systems as needed",
                    "Test related functionality"
                ],
                "system_updates_needed": [
                    "Review file changes manually",
                    "Update related configurations",
                    "Notify relevant team members",
                    "Document changes for future reference"
                ]
            }
        
        # Create JIRA ticket
        try:
            print(f"üé´ Creating JIRA ticket in {JIRA_PROJECT_KEY}...")
            
            jira = JIRA(
                server=os.getenv('JIRA_URL'),
                basic_auth=(os.getenv('JIRA_EMAIL'), os.getenv('JIRA_API_TOKEN'))
            )
            
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            description = f"""# {MONITOR_NAME} Update Detected
        
        ## Summary
        {analysis['summary']}
        
        ## Change Details
        * **Detection Time**: {timestamp} UTC
        * **Monitored File**: {MONITOR_NAME}
        * **File URL**: {MONITORED_URL}
        * **Changes Count**: {analysis['total_changes']}
        * **Priority**: {analysis['priority'].upper()}
        * **Hash Change**: `{prev_hash}` ‚Üí `{curr_hash}`
        * **Source**: GitHub Actions Monitor
        
        ## Detected Changes
        """
            
            for change in analysis['changes']:
                description += f"* **{change['change_type'].upper()}**: {change['item_name']} - {change['details']} (Impact: {change['impact_level']})\n"
            
            description += "\n## Required Actions\n"
            for i, action in enumerate(analysis['action_items'], 1):
                description += f"{i}. {action}\n"
            
            description += "\n## System Updates Needed\n"
            for i, update in enumerate(analysis['system_updates_needed'], 1):
                description += f"{i}. {update}\n"
            
            description += f"""
        ## Resources
        * [Monitored File]({MONITORED_URL})
        * [GitHub Actions Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
        * [Monitor Repository](https://github.com/${{ github.repository }})
        
        ## Next Steps
        1. **Review**: Check the file changes manually
        2. **Update**: Apply necessary system updates  
        3. **Test**: Verify dependent functionality
        4. **Complete**: Mark ticket resolved when done
        
        ---
        *Auto-generated by {MONITOR_NAME} Monitor*
        """
            
            # Create JIRA issue
            issue_dict = {
                'project': {'key': JIRA_PROJECT_KEY},
                'summary': f"{MONITOR_NAME} Updated - Changes Detected ({datetime.now().strftime('%Y-%m-%d')})",
                'description': description,
                'issuetype': {'name': 'Task'},
                'priority': {'name': 'Medium'}
            }
            
            new_issue = jira.create_issue(fields=issue_dict)
            
            # Add labels
            try:
                labels = ['file-monitor', 'automation', MONITOR_NAME.lower().replace(' ', '-')]
                new_issue.update(fields={'labels': labels})
            except:
                pass
            
            print(f"‚úÖ JIRA ticket created successfully!")
            print(f"üé´ Ticket: {new_issue.key}")
            print(f"üîó URL: {os.getenv('JIRA_URL')}/browse/{new_issue.key}")
            
            # Save results
            with open('monitor_results.json', 'w') as f:
                json.dump({
                    'success': True,
                    'ticket_key': new_issue.key,
                    'ticket_url': f"{os.getenv('JIRA_URL')}/browse/{new_issue.key}",
                    'monitor_name': MONITOR_NAME,
                    'changes_detected': True,
                    'priority': analysis['priority'],
                    'timestamp': datetime.now().isoformat()
                }, f, indent=2)
            
        except Exception as e:
            print(f"‚ùå JIRA ticket creation failed: {e}")
            
            with open('monitor_results.json', 'w') as f:
                json.dump({
                    'success': False,
                    'error': str(e),
                    'monitor_name': MONITOR_NAME,
                    'changes_detected': True,
                    'analysis_completed': True
                }, f, indent=2)
        
        print("üèÅ Analysis complete")
        EOF
        
    - name: Store new baseline
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.MONITOR_NAME }}-baseline
        path: current_file.json
        retention-days: 90
        overwrite: true
        
    - name: Display Results
      run: |
        echo "## üìä ${{ env.MONITOR_NAME }} Monitor Results"
        echo "============================================="
        
        if [ "${{ steps.detect_changes.outputs.changes_detected }}" = "true" ]; then
          echo "üö® **CHANGES DETECTED**"
          echo ""
          echo "üìÑ File: ${{ env.MONITORED_FILE_URL }}"
          echo "üìè Size change: ${{ steps.detect_changes.outputs.prev_size }} ‚Üí ${{ steps.detect_changes.outputs.curr_size }} bytes"
          
          if [ -f "monitor_results.json" ]; then
            echo ""
            echo "üé´ **JIRA Ticket Results:**"
            cat monitor_results.json
          fi
          
          echo ""
          echo "‚úÖ **Next Steps:**"
          echo "   1. Check ${{ env.JIRA_PROJECT_KEY }} project for new ticket"
          echo "   2. Review file changes manually"
          echo "   3. Update dependent systems as needed"
          
        elif [ "${{ steps.detect_changes.outputs.first_run }}" = "true" ]; then
          echo "üìÅ **BASELINE ESTABLISHED**"
          echo "   First monitoring run completed successfully"
          echo "   File: ${{ env.MONITORED_FILE_URL }}"
          
        else
          echo "‚úÖ **NO CHANGES DETECTED**"
          echo "   Monitored file unchanged since last check"
        fi
        
        echo ""
        echo "‚è∞ Next check: ${{ vars.MONITOR_SCHEDULE || 'Every 6 hours' }}"
        echo "üîß Manual trigger: Actions ‚Üí ${{ env.MONITOR_NAME }} Monitor ‚Üí Run workflow"
